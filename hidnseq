#!/usr/bin/perl
BEGIN { if (grep {/--debug/} @ARGV) { my @ARGS=grep {!/--debug/} @ARGV; exec($^X, "-d", __FILE__, @ARGS); } }
use v5.36;
use lib '.';
use Time::HiRes qw(time usleep);
use FindBin;
use lib "$FindBin::Bin/lib";
use ButtonGesture::Recognizer;
use Getopt::Long::Descriptive;
use YAML::XS qw(LoadFile);
use IO::Socket::INET;
use IO::Select;
use Term::ReadKey;

my $def_file = "wifi-gestures.yaml";
# $def_file = "my-gestures.yaml";
my $def_quantum_s = 0.02;
my $def_port = 10101;
my $def_hidui_port = 9876;
my $verbose = 2;
sub _ansi_rgb   { return sprintf("\e[38;2;%d;%d;%dm", $_[0], $_[1], $_[2]); }
sub _ansi_bg    { return sprintf("\e[48;2;%d;%d;%dm", $_[0], $_[1], $_[2]); }
sub _ansi_boit  { "\e[1m\e[3m" }
sub _ansi_boit_end { "\e[22m\e[23m" }
sub _ansi_bo  { "\e[1m" }
#my $_ansi_matched = _ansi_bg(40,155,40) . _ansi_rgb(255,255,255) . _ansi_boit;
# my $_ansi_matched = _ansi_rgb(255,255,255) . _ansi_boit;
my $_ansi_matched = "\e[32;1m";
my $_ansi_score = "\e[33;1m";
my $_ansi_reset = "\e[0m";

# Global state for cleanup
my ($mouse_enabled, $server, $recognizer, $hidui_pid, $hidui_client);

# Default fields to show in the visualization lines
my %viz_display = (
	name => 1,
	rel_label => 1,
	usr_label => 0,  # Now shown on OBS line by default
	score => 1,
	weight => 0,
	type => 1,
	quotes => 0,
);


sub main {
    my $patterns = [];
    my $file_dot_ms;
    my $usage_desc = "%c %o";
    my ($opt, $usage) = describe_options(
        $usage_desc,
        [ 'gesture-file|f=s' => "Gesture file .yaml",
            { 'default' => $def_file, } ],
        [ 'net|N'           => "Use network mode instead of mouse" ],
        [ 'port|p=i'        => "Listen port ($def_port) (implies -N)", {
            implies => 'net'
        }],
        [],
        [ 'Mouse button choice for --tui mode' ],
        [ 'lmb'             => "Use Left-Mouse-Button" ],
        [ 'mmb'             => "Use Middle-Mouse-Button (default)" ],
        [ 'rmb'             => "Use Right-Mouse-Button" ],
        [],
        [ 'tui'             => "Text UI only (no HIDUI, for testing gestures)" ],
        [ 'no-hidui'        => "No HIDUI (but still in net-button mode)" ],
        [ 'no-overlay'      => "Disable visual overlay status window" ],
        [ 'hardcoded'       => "Use hard-coded event mappings here in hidnseq (disables hidui)" ],
        [ 'hidui-port=i'    => "HIDUI event port ($def_hidui_port)" ],
        [ 'quantum-s|q=f'   => "Smallest resolution of sensing durations (seconds, float ($def_quantum_s)",
            { 'default' => $def_quantum_s, } ],
        [ 'verbose|v+'  => "Increase verbosity each time -v is used",
            { 'default' => $verbose, } ],
        [],
        [ 'help|h'      => "Show this help", { shortcircuit => 1 } ],
    );
    print($usage->text), exit if $opt->help;
    my $watch_btn = $opt->lmb ? 0 : $opt->rmb ? 2 : 1; # 1 is mmb

    $verbose = $opt->verbose;
    my $use_net = 0;
	$use_net = 1 if $opt->net;
    my $port = $opt->port // $def_port;
    my $tui_mode = $opt->tui // 0;
    my $hidui_mode = !$opt->no_hidui;
    my $hidui_port = $opt->hidui_port // $def_hidui_port;
    my $hardcoded = $opt->hardcoded // 0;
    $hidui_mode = !$hardcoded;

    if ($opt->gesture_file) {
        die "No such YAML: " . $opt->gesture_file . "\n"
            unless -f $opt->gesture_file;
        my $raw = LoadFile($opt->gesture_file);
        $file_dot_ms = (ref($raw) eq 'HASH' && exists $raw->{dot_ms}) ? 0.0 + $raw->{dot_ms} : undef;
        my $in = ref($raw) eq 'HASH' ? ($raw->{patterns} // $raw->{gestures} // []) : $raw;
        $patterns = _normalize_patterns($in, '.', '~');   # parse visual (incl. {dots}) → runs[len], merge variance/weight
    }

    my $quantum_s = defined($file_dot_ms) ? ($file_dot_ms / 1000.0) : $opt->quantum_s;

    # Create overlay unless disabled
    my $overlay;
    unless ($opt->no_overlay) {
        require ButtonGesture::OverlayStatus;
        ButtonGesture::OverlayStatus->import();
        $overlay = ButtonGesture::OverlayStatus->new(
            patterns => $patterns,
            quantum_s => $quantum_s,
            width_px => 200,
            height_px => 30,
        );
    }

    # Start HIDUI unless in TUI mode
    # unless ($tui_mode && !$hidui_mode) {
    if (!$tui_mode && $hidui_mode) {
        start_hidui($hidui_port);
    }

    $recognizer = Recognizer->new(
        verbose    => $verbose,
        quantum_ms => int($quantum_s * 1000 + 0.5),
        callback   => sub { handle_gesture(@_, $tui_mode, $hidui_port, $hardcoded) },
        overlay_update => $overlay ? sub { $overlay->update(@_) } : undef,
        patterns   => $patterns,
        commit_threshold   => 0.45,   # still require a strong match
        commit_margin      => 0.018,   # need a bigger lead over any continuation
        decision_timeout_s => 0.34,   # max patience window once a full candidate exists
        #viz_pats_full      => 0,
        prefer_longer_margin => 0.15,   # promotes .~.~ over .~ when close
        #commit_threshold     => 0.80,
        #commit_margin        => 0.18,
        #run_weight_dot   => 1.8,
        #run_weight_tilde => 1.0,
        #press_bias       => 0.35,
        tie_epsilon      => 0.03,
        # patience tunes how much weight UBs of non-best candidates get (1.0 = neutral)
        patience           => 1.20,
        # safety net timeouts; keep or tweak later
        hard_stop_idle_s   => 1.00,
        hard_stop_span_s   => 0.00,
        # keep dot-end guard unless you know you want to commit while still pressed
        require_release_for_dot_end => 1,
        viz_display => \%viz_display,
        viz_scale => .75,
    );
    my $idle_tick_s = $quantum_s;
    my $last_feed   = time();

    # Mode-specific setup
    my ($sel_net, $client);
	ReadMode('cbreak');

    if ($use_net) {
        # Network mode
        $server = IO::Socket::INET->new(
            LocalPort => $port,
            Proto     => 'tcp',
            Listen    => 5,
            Reuse     => 1,
        ) or die "Cannot create socket on port $port: $!\n";
        $sel_net = IO::Select->new($server);

        print "=" x 60 . "\n";
        print "Gesture Recognizer (Network Mode)\n";
        if ($tui_mode) {
            print "(TUI Mode - No HIDUI)\n";
        } else {
            print "(Sending events to HIDUI on port $hidui_port)\n";
        }
        print "=" x 60 . "\n";
        print "Listening on port: $port\n";
    } else {
        # Mouse mode (default)
        print "\e[?1000;1003;1006h";  # enable full mouse tracking
        $mouse_enabled = 1;

        # Clear screen and show instructions
        # print "\e[2J\e[H";  # Clear screen and move to top
        print "\n" x 5;
        print "=" x 60 . "\n";
        print "Mouse Gesture Recognizer Test\n";
        if ($tui_mode) {
            print "(TUI Mode - No HIDUI)\n";
        } else {
            print "(Sending events to HIDUI on port $hidui_port)\n";
        }
        print "=" x 60 . "\n";
    }

    # Common display
    print "Available gestures:\n";
	# Need to retrieve from yaml and display to user
	# eg. print "  - click: description...\n";
	for my $p (@$patterns) {
		print "  - " . $p->{name} . "\n";
	}
    print "\n";

    if ($use_net) {
        print "Waiting for network connection. Press 'q' or Ctrl-C to quit.\n";
    } else {
        print "Left-click anywhere to test gestures. Press 'q' or Ctrl-C to quit.\n";
    }
    print "-" x 60 . "\n\n";

    # Setup signal handler for clean exit
    $SIG{INT} = sub { cleanup() };

    my $last_update = time();
    while (1) {
        # Always check for keyboard input (works in both modes)
        my $c = ReadKey(-1);

        if (defined $c) {
            if ($c eq "q") {
                say "QUIT";
                last;
            } elsif ($c eq "\n") {
                print "\n" x 50;
            } elsif (!$use_net && $c eq "\e") {
                # Mouse mode: handle mouse sequences
                my $seq = $c;
                my $next;
                while (defined($next = Term::ReadKey::ReadKey(-1))) {
                    $seq .= $next;
                    last if $next =~ /[A-Za-z~]$/;
                }
                if ($seq =~ /\e\[<(\d+);(\d+);(\d+)([Mm])/) {
                    my ($btn, $x, $y, $state) = ($1, $2, $3, $4);
                    if ($btn == $watch_btn) {
                        if ($state eq 'M') {
                            $recognizer->press(time());
                        } else {
                            $recognizer->release(time());
                        }
                        $last_feed = time();
                    }
                }
            }
        }

        if ($use_net) {
            # Network mode: handle connections
            my @ready = $sel_net->can_read(0.001);

            foreach my $fh (@ready) {
                if ($fh == $server) {
                    # New connection
                    $client = $server->accept();
                    $sel_net->add($client);
                    print "Client connected from ", $client->peerhost(), "\n";
                } else {
                    # Data from client
                    my $line = <$fh>;
                    if (!defined $line) {
                        # Client disconnected
                        print "Client disconnected\n";
                        $sel_net->remove($fh);
                        $fh->close();
                        $client = undef if $fh == $client;
                        next;
                    }

                    chomp($line);
                    $line =~ s/\r//g;
                    $line =~ s/^\s+|\s+$//g;

                    # Parse pat-press or pat-release
                    if ($line =~ /^pat-press/) {
                        $recognizer->press(time());
                        $last_feed = time();
                    } elsif ($line =~ /^pat-release/) {
                        $recognizer->release(time());
                        $last_feed = time();
                    }
                }
            }
        } else {
            # Mouse mode
            my $c = Term::ReadKey::ReadKey(-1);
            if (defined $c) {
                if ($c eq "q") {
                    say "QUIT\n";
                    last;
                } elsif ($c eq "\n") {
                    print "\n" x 50;
                } elsif ($c eq "\e") {
                    my $seq = $c;
                    my $next;
                    while (defined($next = Term::ReadKey::ReadKey(-1))) {
                        $seq .= $next;
                        last if $next =~ /[A-Za-z~]$/;
                    }
                    if ($seq =~ /\e\[<(\d+);(\d+);(\d+)([Mm])/) {
                        my ($btn, $x, $y, $state) = ($1, $2, $3, $4);
                        if ($btn == 0) {
                            if ($state eq 'M') {
                                $recognizer->press(time());
                            } else {
                                $recognizer->release(time());
                            }
                            $last_feed = time();
                        }
                    } else {
                        # Ignore other finalized term sequences that we don't care about
                        if ($next =~ /[A-Za-z~]$/) {
                            # my $seqshow = $seq; $seqshow =~ s/\033/^[/g; say "SEQ: {{$seqshow}}";
                            $seq = '';
                            next;
                        }
                    }
                }
            }
        }

        if (time() - $last_feed >= $idle_tick_s) {
            $recognizer->tick(time());
            $last_feed = time();
        }

        usleep(1000);
    }
}

# Start HIDUI in background
sub start_hidui {
    my ($port) = @_;

    # Fork and start HIDUI
    $hidui_pid = fork();

    if (!defined $hidui_pid) {
        warn "Failed to fork HIDUI process: $!\n";
        return;
    }

    if ($hidui_pid == 0) {
        # Child process - exec HIDUI
        my $hidui_script = "$FindBin::Bin/hidui/hidui";

        unless (-x $hidui_script) {
            die "HIDUI script not found or not executable: $hidui_script\n";
        }

        exec($^X, $hidui_script, "--port", $port);
        die "Failed to exec HIDUI: $!\n";
    }

    # Parent process - wait for HIDUI to start and be ready
    print "Starting HIDUI (PID: $hidui_pid) on port $port...\n";

    # Wait for HIDUI to actually be listening
    my $max_tries = 20;  # 10 seconds max
    my $ready = 0;

    for my $attempt (1 .. $max_tries) {
        usleep(500000);

        # Try to connect
        my $test_sock = IO::Socket::INET->new(
            PeerHost => 'localhost',
            PeerPort => $port,
            Proto => 'tcp',
            Timeout => 1,
        );

        if ($test_sock) {
            close $test_sock;
            $ready = 1;
            print "HIDUI ready after $attempt attempt(s).\n";
            last;
        }
    }

    unless ($ready) {
        warn "WARNING: HIDUI may not be ready (couldn't connect to port $port)\n";
    }
}

# Send event to HIDUI
sub send_to_hidui {
    my ($event_name, $port) = @_;

    return unless defined $event_name && $event_name ne '';

    # Create fresh connection each time (simpler and more reliable)
    my $client = IO::Socket::INET->new(
        PeerHost => 'localhost',
        PeerPort => $port,
        Proto => 'tcp',
        Timeout => 2,
    );

    unless ($client) {
        warn "Cannot connect to HIDUI on port $port: $!\n";
        return 0;
    }

    print $client "$event_name\n";
    close $client;

    return 1;
}

# Non-blocking stdin check for network mode
sub _check_stdin {
    use IO::Select;
    state $sel = IO::Select->new(\*STDIN);
    my @ready = $sel->can_read(0);
    return undef unless @ready;

    my $c;
    sysread(STDIN, $c, 1);
    return $c;
}

sub handle_gesture {
    my ($gesture_name, $score, $meta, $tui_mode, $hidui_port, $hardcoded) = @_;
    my $when = ($meta && exists $meta->{t_end}) ? $meta->{t_end} : time();
    if ($gesture_name && $gesture_name eq 'NO_MATCH') {
        print "\nNo match (reset)\n";
        print "at: $when  ---  ";
    } else {
        my $score_s = defined($score) ? sprintf('%.3f',$score) : '—';
        print "\nMatched: $_ansi_matched $gesture_name $_ansi_reset  score=$_ansi_score$score_s$_ansi_reset\n";
        print "at: $when  ---  ";
        if ($hardcoded) {
            if ($gesture_name eq 'click') {
                `xdotool key Up`;
            } elsif ($gesture_name eq 'doubleclick') {
                `xdotool key Up`;
            } elsif ($gesture_name eq 'tripleclick') {
                for my $i (0 .. 10) {
                    `xdotool key Down`;
                }
            } elsif ($gesture_name eq 'longpress') {
                for my $i (0 .. 10) {
                    `xdotool key Up`;
                }
            }
        } else {
            # Send to HIDUI if we're not doing TUI test mode (no gui)
            if (!$tui_mode) {
                if (send_to_hidui($gesture_name, $hidui_port)) {
                    print "[Sent to HIDUI] ";
                } else {
                    print "[HIDUI send failed] ";
                }
            }
        }
    }
    print "(q) or Ctrl-C to quit\n";
}

sub cleanup {
    if ($mouse_enabled) {
        print "\e[?1000;1003;1006l";  # disable mouse tracking
        print "\nMouse tracking disabled. Exiting.\n";
    }
    ReadMode('restore');
    if ($server) {
        $server->close();
        print "\nServer closed. Exiting.\n";
    }
    if ($hidui_client) {
        $hidui_client->close();
    }
    if ($hidui_pid) {
        print "Shutting down HIDUI (PID: $hidui_pid)...\n";
        kill 'TERM', $hidui_pid;
        waitpid($hidui_pid, 0);
    }
    exit;
}

END {
    cleanup()
}

# --- helpers: parse visual (including .{N}/~{N}) and merge per-run metadata ----
sub _normalize_patterns ($list, $sym_press, $sym_release) {
    my @out;
    for my $p (@$list) {
        my @runs = ();
        if (defined $p->{visual} && length $p->{visual}) {
            @runs = _parse_visual_to_runs($p->{visual}, $sym_press, $sym_release);
        }
        # Merge per-run metadata (variance/weight) if provided
        if (exists $p->{runs}) {
            my @meta = map { $p->{runs}{$_} } sort { $a <=> $b } keys %{$p->{runs}};
            for my $i (0 .. $#runs) {
                my $m = $meta[$i] // {};
                $runs[$i]{variance} = exists $m->{variance} ? 0.0 + $m->{variance}
                                   : ($runs[$i]{type} eq 'release' ? 2.0 : 1.0);
                $runs[$i]{weight}   = exists $m->{weight}   ? 0.0 + $m->{weight}   : 1.0;
            }
        } else {
            for my $r (@runs) {
                $r->{variance} //= ($r->{type} eq 'release' ? 2.0 : 1.0);
                $r->{weight}   //= 1.0;
            }
        }
        push @out, {
            id      => $p->{id}   // $p->{name} // 'pattern',
            name    => $p->{name} // $p->{id}   // 'pattern',
            weight  => (defined $p->{weight} ? 0.0 + $p->{weight} : 1.0),
            runs    => \@runs,
        };
    }
    return \@out;
}

sub _parse_visual_to_runs ($visual, $sym_press, $sym_release) {
    my @runs;
    my @chars = split //, $visual;
    my $i = 0;
    while ($i <= $#chars) {
        my $ch = $chars[$i];
        if ($ch eq $sym_press || $ch eq $sym_release) {
            my $type = ($ch eq $sym_release) ? 'release' : 'press';
            # check for brace-form immediately after
            if ($i+1 <= $#chars && $chars[$i+1] eq '{') {
                # parse {number}
                my $j = $i+2; my $num = '';
                while ($j <= $#chars && $chars[$j] ne '}') { $num .= $chars[$j]; $j++; }
                if ($j <= $#chars && $chars[$j] eq '}') {
                    my $dots = 0.0 + $num;
                    push @runs, { sym=>$ch, type=>$type, len=>$dots };
                    $i = $j + 1;
                    next;
                }
                # malformed; fall through to counting
            }
            # count raw glyph run
            my $count = 1;
            my $k = $i+1;
            while ($k <= $#chars && $chars[$k] eq $ch) { $count++; $k++; }
            push @runs, { sym=>$ch, type=>$type, len=>$count };
            $i = $k;
            next;
        }
        # skip any other chars/spaces
        $i++;
    }
    return @runs;
}

main();

# vim: et ts=4 sts=4 sw=4
