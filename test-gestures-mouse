#!/usr/bin/perl
use v5.36;
use lib '.';
use Term::ReadKey;
use Time::HiRes qw(time usleep);
use FindBin;
use lib "$FindBin::Bin/lib";
use ButtonGesture::Recognizer;
use Getopt::Long;
use YAML::XS qw(LoadFile);

my $file = "my-gestures.yaml";
my $quantum_s = 0.02;
my $verbose = 1;
GetOptions(
  'file|f=s'    => \$file,
  'quantum|q=f' => \$quantum_s,
  'verbose|v!'  => \$verbose,
) or die "Usage: $0 [-f gestures.yaml] [-q QUANTUM_SECONDS] [-v]\n";

my $gestures = [];
if ($file) {
  die "No such YAML: $file\n" unless -f $file;
  my $raw = LoadFile($file);
  $gestures = ref($raw) eq 'HASH' ? ($raw->{gestures} // []) : $raw;
}

my $recognizer = ButtonGesture::Recognizer->new(
    verbose    => $verbose,
    quantum_s  => $quantum_s,
    callback => \&handle_gesture,
    gestures   => $gestures,
);

my $idle_tick_s = $quantum_s;
my $last_feed   = time();

# Enable raw input mode and mouse tracking
ReadMode('cbreak');
print "\e[?1000;1003;1006h";  # enable full mouse tracking

# Setup signal handler for clean exit
$SIG{INT} = sub { cleanup() };

# Clear screen and show instructions
print "\e[2J\e[H";  # Clear screen and move to top
print "=" x 60 . "\n";
print "Mouse Gesture Recognizer Test\n";
print "=" x 60 . "\n";
print "Available gestures:\n";
print "  - Tap: Quick click\n";
print "  - Double Tap: Two quick clicks\n";
print "  - Long Press: Hold for ~500ms\n";
print "  - Triple Tap: Three quick clicks\n";
print "  - Press-Tap: Long press, release, then tap\n";
print "\n";
print "Left-click anywhere to test gestures. Press Ctrl-C to quit.\n";
print "-" x 60 . "\n\n";

my $last_update = time();

# while (1) {
#     my $c = ReadKey(-1);
#     if (defined $c) {
#     	if (&& $c eq "\e") {
#             my $seq = $c;
#             while (defined(my $next = ReadKey(-1))) {
#                 $seq .= $next;
#             last if $next =~ /[A-Za-z~]$/;
#             }
#             if ($seq =~ /\e\[<(\d+);(\d+);(\d+)([Mm])/) {
#                 my ($btn, $x, $y, $state) = ($1, $2, $3, $4);
#             if ($btn == 0) {
#                 if ($state eq 'M') {
#                     $recognizer->feed_event('press', time());
#                     } else {
#                     $recognizer->feed_event('release', time());
#                 }
#                 $last_feed = time();
#             }
#         }
#     }
    
#     if (time() - $last_feed >= $idle_tick_s) {
#         $recognizer->tick(time());
#         $last_feed = time();
#     }
    
#     usleep(1000);
# }

while (1) {
    my $c = ReadKey(-1);
    if (defined $c) {
    	if ($c eq "\n") {
    		say '';
		} elsif ($c eq "\e") {
            my $seq = $c;
            while (defined(my $next = ReadKey(-1))) {
                $seq .= $next;
				last if $next =~ /[A-Za-z~]$/;
            }
            if ($seq =~ /\e\[<(\d+);(\d+);(\d+)([Mm])/) {
                my ($btn, $x, $y, $state) = ($1, $2, $3, $4);
				if ($btn == 0) {
					if ($state eq 'M') {
						$recognizer->feed_event('press', time());
					} else {
						$recognizer->feed_event('release', time());
					}
					$last_feed = time();
				}
			}
        }
    }
    
    if (time() - $last_feed >= $idle_tick_s) {
        $recognizer->tick(time());
        $last_feed = time();
    }
    
    usleep(1000);
}

sub handle_gesture {
    my ($gesture_name, $score, $meta) = @_;
    print "\nMatched: $gesture_name  score=$score\n";
    print "at: $meta->{t_end}\n" if $meta && exists $meta->{t_end};
}

sub cleanup {
    print "\e[?1000;1003;1006l";  # disable mouse tracking
    ReadMode('restore');
    print "\nMouse tracking disabled. Exiting.\n";
    exit;
}
