#!/usr/bin/perl
use strict;
use warnings;
use lib '.';  # Look for modules in current directory
use Term::ReadKey;
use Time::HiRes qw(time usleep);
use FindBin;
use lib "$FindBin::Bin/lib";
use ButtonGesture::Recognizer;

# Create recognizer with verbose output
my $recognizer = ButtonGesture::Recognizer->new(
    verbose => 1,
    callback => \&handle_gesture,
    gestures => 'rs-gestures.yaml',
);

# Enable raw input mode and mouse tracking
ReadMode('cbreak');
print "\e[?1000;1003;1006h";  # enable full mouse tracking

# Setup signal handler for clean exit
$SIG{INT} = sub { cleanup() };

# Clear screen and show instructions
print "\e[2J\e[H";  # Clear screen and move to top
print "=" x 60 . "\n";
print "Mouse Gesture Recognizer Test\n";
print "=" x 60 . "\n";
print "Available gestures:\n";
print "  - Tap: Quick click\n";
print "  - Double Tap: Two quick clicks\n";
print "  - Long Press: Hold for ~500ms\n";
print "  - Triple Tap: Three quick clicks\n";
print "  - Press-Tap: Long press, release, then tap\n";
print "\n";
print "Left-click anywhere to test gestures. Press Ctrl-C to quit.\n";
print "-" x 60 . "\n\n";

my $last_update = time();

while (1) {
    my $c = ReadKey(-1);  # Non-blocking read
    
    if (defined $c) {
        if ($c eq "\e") {                      # ESC sequence
            my $seq = $c;
            while (defined(my $next = ReadKey(-1))) {
                $seq .= $next;
                last if $next =~ /[A-Za-z~]$/; # end of escape sequence
            }
            
            # Match SGR mouse event: ESC [ < btn ; x ; y M or m
            if ($seq =~ /\e\[<(\d+);(\d+);(\d+)([Mm])/) {
                my ($btn, $x, $y, $state) = ($1, $2, $3, $4);
                my $pressed = ($state eq 'M');
                
                if ($btn == 0) { # Left button
                    if ($pressed) {
                        $recognizer->button_press();
                    } else {
                        $recognizer->button_release();
                    }
                }
            }
        }
    }
    
    # Periodic update for timeout checking
    my $now = time();
    if ($now - $last_update > 0.01) {  # Update every 50ms
        $recognizer->periodic_update();
        $last_update = $now;
    }
    
    # Small sleep to prevent CPU spinning
    usleep(1000);  # 1ms
}

sub handle_gesture {
    my ($gesture_name, $details) = @_;
    
    my $timestamp = sprintf("%.2f", time());
    print "\n";
    print "!" x 40 . "\n";
    print "GESTURE RECOGNIZED: $gesture_name\n";
    print "Score: $details->{score}\n";
    print "Time: $timestamp\n";
    print "!" x 40 . "\n\n";
    
    # You could dispatch to actual functions here
    if ($gesture_name eq 'tap') {
        print ">> Executing primary action\n";
    } elsif ($gesture_name eq 'double_tap') {
        print ">> Opening menu\n";
    } elsif ($gesture_name eq 'long_press') {
        print ">> Activating secondary function\n";
    } elsif ($gesture_name eq 'triple_tap') {
        print ">> Emergency action\n";
    } elsif ($gesture_name eq 'press_tap') {
        print ">> Special combo detected\n";
    }
    
    print "\n";
}

sub cleanup {
    print "\e[?1000;1003;1006l";  # disable mouse tracking
    ReadMode('restore');
    print "\nMouse tracking disabled. Exiting.\n";
    exit;
}
